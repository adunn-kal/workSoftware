<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WaterSense: Queue&lt; dataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wave.png"/></td>
  <td id="projectalign">
   <div id="projectname">WaterSense<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Firmware to measure waves and tides in marine environments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Queue&lt; dataType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements a queue to transmit data from one RTOS task to another.  
 <a href="class_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="taskqueue_8h_source.html">taskqueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Queue&lt; dataType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_queue.png" usemap="#Queue_3C_20dataType_20_3E_map" alt=""/>
  <map id="Queue_3C_20dataType_20_3E_map" name="Queue_3C_20dataType_20_3E_map">
<area href="class_base_share.html" title="Base class for classes that share data in a thread-safe manner between tasks." alt="BaseShare" shape="rect" coords="0,0,126,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4a3fd660457ea5f5a4f3605322db150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ae4a3fd660457ea5f5a4f3605322db150">Queue</a> (BaseType_t queue_size, const char *p_name=NULL, TickType_t=portMAX_DELAY)</td></tr>
<tr class="memdesc:ae4a3fd660457ea5f5a4f3605322db150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a queue object, allocating memory for the buffer.  <a href="class_queue.html#ae4a3fd660457ea5f5a4f3605322db150">More...</a><br /></td></tr>
<tr class="separator:ae4a3fd660457ea5f5a4f3605322db150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7859c00b2e2818183bfd54979091e60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60">put</a> (const dataType item)</td></tr>
<tr class="memdesc:ae7859c00b2e2818183bfd54979091e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue behind other items.  <a href="class_queue.html#ae7859c00b2e2818183bfd54979091e60">More...</a><br /></td></tr>
<tr class="separator:ae7859c00b2e2818183bfd54979091e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331cd54d6b3052b4d72ad24310be5e90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a331cd54d6b3052b4d72ad24310be5e90">ISR_put</a> (const dataType item)</td></tr>
<tr class="memdesc:a331cd54d6b3052b4d72ad24310be5e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue from within an ISR.  <a href="class_queue.html#a331cd54d6b3052b4d72ad24310be5e90">More...</a><br /></td></tr>
<tr class="separator:a331cd54d6b3052b4d72ad24310be5e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c592b245b39ce229b157935f5a65fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ad3c592b245b39ce229b157935f5a65fa">butt_in</a> (const dataType item)</td></tr>
<tr class="memdesc:ad3c592b245b39ce229b157935f5a65fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue to be retrieved first.  <a href="class_queue.html#ad3c592b245b39ce229b157935f5a65fa">More...</a><br /></td></tr>
<tr class="separator:ad3c592b245b39ce229b157935f5a65fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6ce3a61ea4bcdd4699fd639e2a6137"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#aca6ce3a61ea4bcdd4699fd639e2a6137">ISR_butt_in</a> (const dataType item)</td></tr>
<tr class="memdesc:aca6ce3a61ea4bcdd4699fd639e2a6137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the front of the queue from within an ISR.  <a href="class_queue.html#aca6ce3a61ea4bcdd4699fd639e2a6137">More...</a><br /></td></tr>
<tr class="separator:aca6ce3a61ea4bcdd4699fd639e2a6137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b240bc3f080ea3656d0847b5d291095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a7b240bc3f080ea3656d0847b5d291095">is_empty</a> (void)</td></tr>
<tr class="memdesc:a7b240bc3f080ea3656d0847b5d291095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty.  <a href="class_queue.html#a7b240bc3f080ea3656d0847b5d291095">More...</a><br /></td></tr>
<tr class="separator:a7b240bc3f080ea3656d0847b5d291095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ac0d4a3d7feae804dea7f3cc72f21c624">ISR_is_empty</a> (void)</td></tr>
<tr class="memdesc:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty, from within an ISR.  <a href="class_queue.html#ac0d4a3d7feae804dea7f3cc72f21c624">More...</a><br /></td></tr>
<tr class="separator:ac0d4a3d7feae804dea7f3cc72f21c624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df528749e226183df3fa5472368e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a14df528749e226183df3fa5472368e82">get</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a14df528749e226183df3fa5472368e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve and remove the item at the head of the queue.  <a href="class_queue.html#a14df528749e226183df3fa5472368e82">More...</a><br /></td></tr>
<tr class="separator:a14df528749e226183df3fa5472368e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24699e7027efd7da838f9a1037e29b5"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5">get</a> (void)</td></tr>
<tr class="memdesc:ae24699e7027efd7da838f9a1037e29b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve, remove, and return the item at the head of the queue.  <a href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5">More...</a><br /></td></tr>
<tr class="separator:ae24699e7027efd7da838f9a1037e29b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd37b4f184be25ecebf7957900321bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#afd37b4f184be25ecebf7957900321bbf">ISR_get</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:afd37b4f184be25ecebf7957900321bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the item at the head of the queue from within an ISR.  <a href="class_queue.html#afd37b4f184be25ecebf7957900321bbf">More...</a><br /></td></tr>
<tr class="separator:afd37b4f184be25ecebf7957900321bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf984762445f0361ff8aed3a33d78409"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#acf984762445f0361ff8aed3a33d78409">ISR_get</a> (void)</td></tr>
<tr class="memdesc:acf984762445f0361ff8aed3a33d78409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve, remove, and return the item at the head of the queue when called by ISR code.  <a href="class_queue.html#acf984762445f0361ff8aed3a33d78409">More...</a><br /></td></tr>
<tr class="separator:acf984762445f0361ff8aed3a33d78409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44557ed37c98580b87d0196908330bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a44557ed37c98580b87d0196908330bcc">peek</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a44557ed37c98580b87d0196908330bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the item at the queue head without removing it.  <a href="class_queue.html#a44557ed37c98580b87d0196908330bcc">More...</a><br /></td></tr>
<tr class="separator:a44557ed37c98580b87d0196908330bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b721db58328663cc8d5466d757fa51"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a98b721db58328663cc8d5466d757fa51">peek</a> (void)</td></tr>
<tr class="memdesc:a98b721db58328663cc8d5466d757fa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the item at the queue head without removing it.  <a href="class_queue.html#a98b721db58328663cc8d5466d757fa51">More...</a><br /></td></tr>
<tr class="separator:a98b721db58328663cc8d5466d757fa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ad13824fab4dfa026ef5cf138ca05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a087ad13824fab4dfa026ef5cf138ca05">ISR_peek</a> (dataType &amp;recv_item)</td></tr>
<tr class="memdesc:a087ad13824fab4dfa026ef5cf138ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the item at the front of the queue without deleting it, from within an ISR.  <a href="class_queue.html#a087ad13824fab4dfa026ef5cf138ca05">More...</a><br /></td></tr>
<tr class="separator:a087ad13824fab4dfa026ef5cf138ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e84117611c6074e37a339e9b5b901"><td class="memItemLeft" align="right" valign="top">dataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a2e7e84117611c6074e37a339e9b5b901">ISR_peek</a> (void)</td></tr>
<tr class="memdesc:a2e7e84117611c6074e37a339e9b5b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the item at the front of the queue without deleting it, from within an ISR.  <a href="class_queue.html#a2e7e84117611c6074e37a339e9b5b901">More...</a><br /></td></tr>
<tr class="separator:a2e7e84117611c6074e37a339e9b5b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">any</a> (void)</td></tr>
<tr class="memdesc:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has contents which can be read.  <a href="class_queue.html#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">More...</a><br /></td></tr>
<tr class="separator:a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f764fa35a4880b277a2b6d23651f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a61f764fa35a4880b277a2b6d23651f45">operator&lt;&lt;</a> (dataType new_data)</td></tr>
<tr class="memdesc:a61f764fa35a4880b277a2b6d23651f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator which inserts data into the queue.  <a href="class_queue.html#a61f764fa35a4880b277a2b6d23651f45">More...</a><br /></td></tr>
<tr class="separator:a61f764fa35a4880b277a2b6d23651f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6d1c4c6d4c3e397aa4f194f4ad2ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#adc6d1c4c6d4c3e397aa4f194f4ad2ffb">operator&gt;&gt;</a> (dataType &amp;put_here)</td></tr>
<tr class="memdesc:adc6d1c4c6d4c3e397aa4f194f4ad2ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the queue.  <a href="class_queue.html#adc6d1c4c6d4c3e397aa4f194f4ad2ffb">More...</a><br /></td></tr>
<tr class="separator:adc6d1c4c6d4c3e397aa4f194f4ad2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80711abebd086d5617e5c88dbd87b77a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a80711abebd086d5617e5c88dbd87b77a">ISR_any</a> (void)</td></tr>
<tr class="memdesc:a80711abebd086d5617e5c88dbd87b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue has items in it, from within an ISR.  <a href="class_queue.html#a80711abebd086d5617e5c88dbd87b77a">More...</a><br /></td></tr>
<tr class="separator:a80711abebd086d5617e5c88dbd87b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bef71a925790602cef9eb6274ae61e3"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a6bef71a925790602cef9eb6274ae61e3">available</a> (void)</td></tr>
<tr class="memdesc:a6bef71a925790602cef9eb6274ae61e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue.  <a href="class_queue.html#a6bef71a925790602cef9eb6274ae61e3">More...</a><br /></td></tr>
<tr class="separator:a6bef71a925790602cef9eb6274ae61e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acce9f67b2549a17a8419536aac396b"><td class="memItemLeft" align="right" valign="top">unsigned portBASE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a1acce9f67b2549a17a8419536aac396b">ISR_available</a> (void)</td></tr>
<tr class="memdesc:a1acce9f67b2549a17a8419536aac396b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the queue, to an ISR.  <a href="class_queue.html#a1acce9f67b2549a17a8419536aac396b">More...</a><br /></td></tr>
<tr class="separator:a1acce9f67b2549a17a8419536aac396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ace8d2d512e49f018c5e2df4b5a2bf810">print_in_list</a> (Print &amp;print_dev)</td></tr>
<tr class="memdesc:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the queue's status to a serial device.  <a href="class_queue.html#ace8d2d512e49f018c5e2df4b5a2bf810">More...</a><br /></td></tr>
<tr class="separator:ace8d2d512e49f018c5e2df4b5a2bf810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">usable</a> (void)</td></tr>
<tr class="memdesc:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this queue is usable.  <a href="class_queue.html#a2f5a7d38f857999a1c4cebe31089b0f7">More...</a><br /></td></tr>
<tr class="separator:a2f5a7d38f857999a1c4cebe31089b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab009e50722f689c48d146125f6d50519"><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_queue.html#ab009e50722f689c48d146125f6d50519">get_handle</a> (void)</td></tr>
<tr class="memdesc:ab009e50722f689c48d146125f6d50519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the FreeRTOS structure which runs this queue.  <a href="class_queue.html#ab009e50722f689c48d146125f6d50519">More...</a><br /></td></tr>
<tr class="separator:ab009e50722f689c48d146125f6d50519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_base_share')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">BaseShare</a> (const char *p_name=NULL)</td></tr>
<tr class="memdesc:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base shared data item.  <a href="class_base_share.html#a73741a4ad0b9b54f6f6da20855c2e30b">More...</a><br /></td></tr>
<tr class="separator:a73741a4ad0b9b54f6f6da20855c2e30b inherit pub_methods_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f72027a717afada4679fd08d08bb4b6 inherit pub_methods_class_base_share"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">print_in_list</a> (Print &amp;printer)=0</td></tr>
<tr class="memdesc:a6f72027a717afada4679fd08d08bb4b6 inherit pub_methods_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print one shared data item within a list.  <a href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">More...</a><br /></td></tr>
<tr class="separator:a6f72027a717afada4679fd08d08bb4b6 inherit pub_methods_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a69b90b10718e9469499375c61cc9c236"><td class="memItemLeft" align="right" valign="top"><a id="a69b90b10718e9469499375c61cc9c236" name="a69b90b10718e9469499375c61cc9c236"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="memdesc:a69b90b10718e9469499375c61cc9c236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hhandle for the FreeTOS queue. <br /></td></tr>
<tr class="separator:a69b90b10718e9469499375c61cc9c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="memItemLeft" align="right" valign="top"><a id="ac7869eacf6bc024b4d8ce25496fdaaed" name="ac7869eacf6bc024b4d8ce25496fdaaed"></a>
TickType_t&#160;</td><td class="memItemRight" valign="bottom"><b>ticks_to_wait</b></td></tr>
<tr class="memdesc:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTOS ticks to wait for empty. <br /></td></tr>
<tr class="separator:ac7869eacf6bc024b4d8ce25496fdaaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ede016bcaf8f330cd87f56a600218b1"><td class="memItemLeft" align="right" valign="top"><a id="a2ede016bcaf8f330cd87f56a600218b1" name="a2ede016bcaf8f330cd87f56a600218b1"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf_size</b></td></tr>
<tr class="memdesc:a2ede016bcaf8f330cd87f56a600218b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of queue buffer in bytes. <br /></td></tr>
<tr class="separator:a2ede016bcaf8f330cd87f56a600218b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="memItemLeft" align="right" valign="top"><a id="acd5a036b50ef0fc8f1e587bb7307cee4" name="acd5a036b50ef0fc8f1e587bb7307cee4"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_full</b></td></tr>
<tr class="memdesc:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes in queue. <br /></td></tr>
<tr class="separator:acd5a036b50ef0fc8f1e587bb7307cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">name</a> [16]</td></tr>
<tr class="memdesc:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the shared item.  <a href="class_base_share.html#abc438f82d56097f13a1e791dcd617a72">More...</a><br /></td></tr>
<tr class="separator:abc438f82d56097f13a1e791dcd617a72 inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">p_next</a></td></tr>
<tr class="memdesc:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the next item in the linked list of shares.  <a href="class_base_share.html#a8077022ea40c4ba44a6ff07ab24cac83">More...</a><br /></td></tr>
<tr class="separator:a8077022ea40c4ba44a6ff07ab24cac83 inherit pro_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_attribs_class_base_share"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_class_base_share')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="class_base_share.html">BaseShare</a></td></tr>
<tr class="memitem:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_base_share.html">BaseShare</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">p_newest</a> = NULL</td></tr>
<tr class="memdesc:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the most recently created shared data item.  <a href="class_base_share.html#a0657d8a02509e79c3bb418aaa9cce33c">More...</a><br /></td></tr>
<tr class="separator:a0657d8a02509e79c3bb418aaa9cce33c inherit pro_static_attribs_class_base_share"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class dataType&gt;<br />
class Queue&lt; dataType &gt;</div><p >Implements a queue to transmit data from one RTOS task to another. </p>
<p >Since multithreaded tasks must not use unprotected shared data items for communication, queues are a primary means of intertask communication. Other means include shared data items (see <code><a class="el" href="taskshare_8h.html" title="Data which can be shared between tasks in a thread-safe manner.">taskshare.h</a></code>) and carrier pigeons. The use of a C++ class template allows the compiler to check that you're putting the correct type of data into each queue and getting the correct type of data out, thus helping to prevent programming mistakes that can corrupt your data.</p>
<p >As a template class, <code>Queue&lt;dataType&gt;</code> can be used to make queues which hold data of many types. "Plain Old Data" types such as <code>bool</code> or <code>uint16_t</code> are supported, of course. But you can also use queues which hold compound data types. For example, if you have <code>class</code> <code>my_data</code> which holds several measurements together in an object, you can make a queue for <code>my_data</code> objects with <code>Queue&lt;my_data&gt;</code>. Each item in the queue will then hold several measurements.</p>
<p >The size of FreeRTOS queues is limited to 255 items in 8-bit microcontrollers whose <code>portBASE_TYPE</code> is an 8-bit number. This is a FreeRTOS feature.</p>
<p >Normal writing and reading are done with methods <code><a class="el" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60" title="Put an item into the queue behind other items.">put()</a></code> and <code><a class="el" href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5" title="Retrieve, remove, and return the item at the head of the queue.">get()</a></code>. Normal writing means that the sending task must wait until there is empty space in the queue, and then it puts a data item into the "back" of the queue, where "back" means that the item in the back of the queue will be read after all items that were previously put into the queue have been read. Normal reading means that when an item is read from the front of the queue, it will then be removed, making space for more items at the back. This process is often used to synchronize tasks, as the reading task's <code><a class="el" href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5" title="Retrieve, remove, and return the item at the head of the queue.">get()</a></code> method blocks, meaning that the reading task gets stuck waiting for an item to arrive in the queue; it won't do anything useful until new data has been read. Note that this is acceptable behavior in an RTOS because the RTOS scheduler will ensure that other tasks get to run even while the reading task is blocking itself waiting for data.</p>
<p >In some cases, one may need to use less normal reading and writing methods. Methods whose name begins with <code>ISR_</code> are to be used only within a hardware interrupt service routine. If there is a need to put data at the front of the queue instead of the back, use <code><a class="el" href="class_queue.html#ad3c592b245b39ce229b157935f5a65fa" title="Put an item into the front of the queue to be retrieved first.">butt_in()</a></code> instead of <code><a class="el" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60" title="Put an item into the queue behind other items.">put()</a></code>. If one needs to read data from the queue without removing that data, the <code>look_at()</code> method allows this to be done. If something particularly unusual needs to be done with the queue, one can use the method <code><a class="el" href="class_queue.html#ab009e50722f689c48d146125f6d50519" title="Return a handle to the FreeRTOS structure which runs this queue.">get_handle()</a></code> to retrieve the handle used by the C language functions in FreeRTOS to access the <a class="el" href="class_queue.html" title="Implements a queue to transmit data from one RTOS task to another.">Queue</a> object's underlying data structure directly.</p>
<h1><a class="anchor" id="queue_usage"></a>
Usage</h1>
<p >The following bits of code show how to set up and use a queue to transfer data of type <code>int16_t</code> from one hypothetical task called <code>task_A</code> to another called <code>task_B</code>.</p>
<p >Near the top of the file which contains <code><a class="el" href="encoder__test_8cpp.html#a7dfd9b79bc5a37d7df40207afbc5431f" title="The usual Arduino setup function which runs once as we start up.">setup()</a></code> we create a queue. The constructor of the <code>Queue&lt;int16_t&gt;</code> class is given the number of items in the queue (10 in this example) and an optional name for the queue: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="taskqueue_8h.html">taskqueue.h</a>&quot;</span></div>
<div class="line">...</div>
<div class="line">Queue&lt;int16_t&gt; hockey_queue (10, <span class="stringliteral">&quot;Puckey&quot;</span>);</div>
<div class="ttc" id="ataskqueue_8h_html"><div class="ttname"><a href="taskqueue_8h.html">taskqueue.h</a></div></div>
</div><!-- fragment --><p> In a location which is before we use the queue in any other file than the one in which the queue was created, we re-declare the queue with the keyword <code>extern</code> to make it accessible to any task within that file: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code hl_class" href="class_queue.html">Queue&lt;int16_t&gt;</a> hockey_queue;</div>
<div class="ttc" id="aclass_queue_html"><div class="ttname"><a href="class_queue.html">Queue</a></div><div class="ttdoc">Implements a queue to transmit data from one RTOS task to another.</div><div class="ttdef"><b>Definition:</b> taskqueue.h:131</div></div>
</div><!-- fragment --><p> In the sending task, data is put into the queue: </p><div class="fragment"><div class="line">int16_t an_item = -3;                 </div>
<div class="line">...</div>
<div class="line">an_item = stick_sensor.get_data (2);  <span class="comment">// Read data from sensor </span></div>
<div class="line">hockey_queue.<a class="code hl_function" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60">put</a> (a_data_item);       <span class="comment">// Put data into queue</span></div>
<div class="ttc" id="aclass_queue_html_ae7859c00b2e2818183bfd54979091e60"><div class="ttname"><a href="class_queue.html#ae7859c00b2e2818183bfd54979091e60">Queue::put</a></div><div class="ttdeci">bool put(const dataType item)</div><div class="ttdoc">Put an item into the queue behind other items.</div><div class="ttdef"><b>Definition:</b> taskqueue.h:506</div></div>
</div><!-- fragment --><p> In the receiving task, data is read from the queue. In typical usage, the call to <code><a class="el" href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5" title="Retrieve, remove, and return the item at the head of the queue.">get()</a></code> will block the receiving task until data has been put into the queue by the sending task: </p><div class="fragment"><div class="line">int16_t data_we_got;                  </div>
<div class="line">...</div>
<div class="line">hockey_queue.get (data_we_got);       <span class="comment">// Get data from the queue</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4a3fd660457ea5f5a4f3605322db150" name="ae4a3fd660457ea5f5a4f3605322db150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a3fd660457ea5f5a4f3605322db150">&#9670;&nbsp;</a></span>Queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;<a class="el" href="class_queue.html">::Queue</a> </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>queue_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>wait_time</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a queue object, allocating memory for the buffer. </p>
<p >This constructor creates the FreeRTOS queue which is wrapped by the <code><a class="el" href="class_queue.html" title="Implements a queue to transmit data from one RTOS task to another.">Queue</a></code> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_size</td><td>The number of items which can be stored in the queue </td></tr>
    <tr><td class="paramname">p_name</td><td>A name to be shown in the list of task shares (default empty String) </td></tr>
    <tr><td class="paramname">wait_time</td><td>How long, in RTOS ticks, to wait for a queue to become empty before a character can be sent. (Default: <code>portMAX_DELAY</code>, which causes the sending task to block until sending occurs.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7eb3e7ac6e9a1ec956a11cbdc7c5a44d" name="a7eb3e7ac6e9a1ec956a11cbdc7c5a44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb3e7ac6e9a1ec956a11cbdc7c5a44d">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::any </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has contents which can be read. </p>
<p >This method allows one to check if the queue has any contents. It must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

</div>
</div>
<a id="a6bef71a925790602cef9eb6274ae61e3" name="a6bef71a925790602cef9eb6274ae61e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bef71a925790602cef9eb6274ae61e3">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue. </p>
<p >This method returns the number of items waiting in the queue. It must <b>not</b> be called from within an interrupt service routine; the method <code>ISR_num_items_in()</code> can be called from within an ISR. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

</div>
</div>
<a id="ad3c592b245b39ce229b157935f5a65fa" name="ad3c592b245b39ce229b157935f5a65fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c592b245b39ce229b157935f5a65fa">&#9670;&nbsp;</a></span>butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the front of the queue to be retrieved first. </p>
<p >This method puts an item into the front of the queue so that it will be received first as long as nothing else is put in front of it. This is not the normal way to put things into a queue; using <code><a class="el" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60" title="Put an item into the queue behind other items.">put()</a></code> to put items into the back of the queue is. If you always use this method, you're making a stack rather than a queue, you weirdo. This method must <b>not</b> be used within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a14df528749e226183df3fa5472368e82" name="a14df528749e226183df3fa5472368e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14df528749e226183df3fa5472368e82">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve and remove the item at the head of the queue. </p>
<p >This method gets the item at the head of the queue and removes that item from the queue. If there's nothing in the queue, this method waits, blocking the calling task, for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae24699e7027efd7da838f9a1037e29b5" name="ae24699e7027efd7da838f9a1037e29b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24699e7027efd7da838f9a1037e29b5">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve, remove, and return the item at the head of the queue. </p>
<p >This method gets the item at the head of the queue and removes it from the queue. A copy of the item's contents is returned. If there's nothing in the queue, this method waits, blocking the calling task, for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the contents of the queue item </dd></dl>

</div>
</div>
<a id="ab009e50722f689c48d146125f6d50519" name="ab009e50722f689c48d146125f6d50519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab009e50722f689c48d146125f6d50519">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::get_handle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a handle to the FreeRTOS structure which runs this queue. </p>
<p >If somebody wants to do something which FreeRTOS queues can do but this class doesn't support, a handle for the queue wrapped by this class can be used to access the queue directly. This isn't commonly done. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the FreeRTOS queue which is wrapped within this C++ class </dd></dl>

</div>
</div>
<a id="a7b240bc3f080ea3656d0847b5d291095" name="a7b240bc3f080ea3656d0847b5d291095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b240bc3f080ea3656d0847b5d291095">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty. </p>
<p >This method checks if the queue is empty. It returns <code>true</code> if there are no items in the queue and <code>false</code> if there are items. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

</div>
</div>
<a id="a80711abebd086d5617e5c88dbd87b77a" name="a80711abebd086d5617e5c88dbd87b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80711abebd086d5617e5c88dbd87b77a">&#9670;&nbsp;</a></span>ISR_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_any </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue has items in it, from within an ISR. </p>
<p >This method allows one to check if the queue has any contents from within an interrupt service routine. It must <b>not</b> be called from within normal, non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if there's something in the queue, <code>false</code> if not </dd></dl>

</div>
</div>
<a id="a1acce9f67b2549a17a8419536aac396b" name="a1acce9f67b2549a17a8419536aac396b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acce9f67b2549a17a8419536aac396b">&#9670;&nbsp;</a></span>ISR_available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned portBASE_TYPE <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of items in the queue, to an ISR. </p>
<p >This method returns the number of items waiting in the queue; it must be called only from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue </dd></dl>

</div>
</div>
<a id="aca6ce3a61ea4bcdd4699fd639e2a6137" name="aca6ce3a61ea4bcdd4699fd639e2a6137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6ce3a61ea4bcdd4699fd639e2a6137">&#9670;&nbsp;</a></span>ISR_butt_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_butt_in </td>
          <td>(</td>
          <td class="paramtype">const dataType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the front of the queue from within an ISR. </p>
<p >This method puts an item into the front of the queue from within an ISR. It must <b>not</b> be used within normal, non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be (rudely) put into the front of the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="afd37b4f184be25ecebf7957900321bbf" name="afd37b4f184be25ecebf7957900321bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd37b4f184be25ecebf7957900321bbf">&#9670;&nbsp;</a></span>ISR_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_get </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the item at the head of the queue from within an ISR. </p>
<p >This method gets and returns the item at the head of the queue from within an interrupt service routine. This method must <b>not</b> be called from within normal non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf984762445f0361ff8aed3a33d78409" name="acf984762445f0361ff8aed3a33d78409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf984762445f0361ff8aed3a33d78409">&#9670;&nbsp;</a></span>ISR_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve, remove, and return the item at the head of the queue when called by ISR code. </p>
<p >This method gets the item at the head of the queue and removes it from the queue. A copy of the item's contents is returned. This method must <b>not</b> be called from within normal non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the contents of the queue item </dd></dl>

</div>
</div>
<a id="ac0d4a3d7feae804dea7f3cc72f21c624" name="ac0d4a3d7feae804dea7f3cc72f21c624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d4a3d7feae804dea7f3cc72f21c624">&#9670;&nbsp;</a></span>ISR_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the queue is empty, from within an ISR. </p>
<p >This method checks if the queue is empty from within an interrupt service routine. It must <b>not</b> be used in normal non-ISR code. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the queue is empty, <code>false</code> if it's not empty </dd></dl>

</div>
</div>
<a id="a087ad13824fab4dfa026ef5cf138ca05" name="a087ad13824fab4dfa026ef5cf138ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087ad13824fab4dfa026ef5cf138ca05">&#9670;&nbsp;</a></span>ISR_peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_peek </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the item at the front of the queue without deleting it, from within an ISR. </p>
<p >This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue, this method doesn't change the value of the data given as its parameter. This method must <b>only</b> be called within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to the item to be filled with data from the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e7e84117611c6074e37a339e9b5b901" name="a2e7e84117611c6074e37a339e9b5b901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7e84117611c6074e37a339e9b5b901">&#9670;&nbsp;</a></span>ISR_peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_peek </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the item at the front of the queue without deleting it, from within an ISR. </p>
<p >This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue, this method returns a default value of the type of data in the queue. This method must <b>only</b> be called within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the data in the queue </dd></dl>

</div>
</div>
<a id="a331cd54d6b3052b4d72ad24310be5e90" name="a331cd54d6b3052b4d72ad24310be5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331cd54d6b3052b4d72ad24310be5e90">&#9670;&nbsp;</a></span>ISR_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::ISR_put </td>
          <td>(</td>
          <td class="paramtype">const dataType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue from within an ISR. </p>
<p >This method puts an item of data into the back of the queue from within an interrupt service routine. It must <b>not</b> be used within non-ISR code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a61f764fa35a4880b277a2b6d23651f45" name="a61f764fa35a4880b277a2b6d23651f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f764fa35a4880b277a2b6d23651f45">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">dataType&#160;</td>
          <td class="paramname"><em>new_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator which inserts data into the queue. </p>
<p >This convenient operator puts data into the queue, protecting the data from corruption by thread switching. It checks if the processor is currently in an interupt service routine (ISR); if so, it calls ISR specific functions to prevent corruption, so this function may be used within an ISR or outside one. It runs a little more slowly than the <code><a class="el" href="class_queue.html#ae7859c00b2e2818183bfd54979091e60" title="Put an item into the queue behind other items.">put()</a></code> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td>The data which is to be put into the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc6d1c4c6d4c3e397aa4f194f4ad2ffb" name="adc6d1c4c6d4c3e397aa4f194f4ad2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6d1c4c6d4c3e397aa4f194f4ad2ffb">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>put_here</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the queue. </p>
<p >This method is used to read data from the queue . The retrieved data is copied into the variable which is given as this method's parameter, replacing the previous contents. This method checks if the processor is currently in an interupt service routine (ISR) and if so, it calls ISR specific functions to prevent corruption, so this function may be used within an ISR or outside one. It runs a little more slowly than the <code><a class="el" href="class_queue.html#ae24699e7027efd7da838f9a1037e29b5" title="Retrieve, remove, and return the item at the head of the queue.">get()</a></code> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">put_here</td><td>A reference to the variable in which to put received data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44557ed37c98580b87d0196908330bcc" name="a44557ed37c98580b87d0196908330bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44557ed37c98580b87d0196908330bcc">&#9670;&nbsp;</a></span>peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">dataType &amp;&#160;</td>
          <td class="paramname"><em>recv_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the item at the queue head without removing it. </p>
<p >This method gets the item at the head of the queue without removing that item from the queue. If there's nothing in the queue this method waits, blocking the calling task, for for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_item</td><td>A reference to a variable to be filled with data from the queue item </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98b721db58328663cc8d5466d757fa51" name="a98b721db58328663cc8d5466d757fa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b721db58328663cc8d5466d757fa51">&#9670;&nbsp;</a></span>peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dataType <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the item at the queue head without removing it. </p>
<p >This method returns the item at the head of the queue without removing that item from the queue. If there's nothing in the queue this method waits, blocking the calling task, for for the number of RTOS ticks specified in the <code>wait_time</code> parameter to the queue constructor (the default is forever) or until something shows up. This method must <b>not</b> be called from within an interrupt service routine. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the data in the item at the head of the queue </dd></dl>

</div>
</div>
<a id="ace8d2d512e49f018c5e2df4b5a2bf810" name="ace8d2d512e49f018c5e2df4b5a2bf810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8d2d512e49f018c5e2df4b5a2bf810">&#9670;&nbsp;</a></span>print_in_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::print_in_list </td>
          <td>(</td>
          <td class="paramtype">Print &amp;&#160;</td>
          <td class="paramname"><em>print_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the queue's status to a serial device. </p>
<p >This method makes a printout of the queue's status on the given serial device, then calls this same method for the next item of thread-safe data in the linked list of items. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_dev</td><td>Reference to the serial device on which to print </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_base_share.html#a6f72027a717afada4679fd08d08bb4b6">BaseShare</a>.</p>

</div>
</div>
<a id="ae7859c00b2e2818183bfd54979091e60" name="ae7859c00b2e2818183bfd54979091e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7859c00b2e2818183bfd54979091e60">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const dataType&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put an item into the queue behind other items. </p>
<p >This method puts an item of data into the back of the queue, which is the normal way to put something into a queue. If you want to be rude and put an item into the front of the queue so it will be retrieved first, use <code><a class="el" href="class_queue.html#ad3c592b245b39ce229b157935f5a65fa" title="Put an item into the front of the queue to be retrieved first.">butt_in()</a></code> instead. <b>This method must not be used within an Interrupt Service Routine.</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item which is going to be put into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the item was successfully queued, false if not </dd></dl>

</div>
</div>
<a id="a2f5a7d38f857999a1c4cebe31089b0f7" name="a2f5a7d38f857999a1c4cebe31089b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5a7d38f857999a1c4cebe31089b0f7">&#9670;&nbsp;</a></span>usable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class dataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_queue.html">Queue</a>&lt; dataType &gt;::usable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this queue is usable. </p>
<p >This method returns a value which is <code>true</code> if this queue has been successfully set up and can be used. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this queue is usable, <code>false</code> if not </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>waterSenseLibraries/ME507-Support/src/<a class="el" href="taskqueue_8h_source.html">taskqueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_queue.html">Queue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
